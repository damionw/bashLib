#!/usr/bin/env bash
#===================================================================================
#                          Import tools library
#===================================================================================
. "$(bashlib --lib)"

#===================================================================================
#                              Logging Options
#===================================================================================
logging::set_severity info

#===================================================================================
#                           Command line option handlers
#===================================================================================
set_logging() {
    logging::set_severity "$(echo "${1}" | sed -e 's/^[\-]*//g')"
}

#===================================================================================
#                              Default Settings
#===================================================================================
conversion_string=
command_string='echo $1'    
processor_count=$(awk '/^processor[ \t]*/{print $NF;}' /proc/cpuinfo | sort -n | tail -1)
job_count=$(( ${processor_count:-2} / 2 ))
source_file="/dev/stdin"

#===================================================================================
#                           Process command line options
#===================================================================================
optionslib::parse::description "Text Queue job processor"

optionslib::parse::config "
    long_options=--help short_options=-h action=show_help description='Display instructions'
    long_options=--debug action=command name=set_logging description='Expose debug level logging'
    long_options=--info action=command name=set_logging  description='Expose normal level logging'
    long_options=--warning action=command name=set_logging  description='Expose error level logging'
    long_options=--error action=command name=set_logging  description='Expose error level logging'
    long_options=--fatal action=command name=set_logging  description='Expose fatal error level logging'
    long_options=--version:: short_options=-v action=command name=bashlib::version description='Produce/Select the library version string'
    long_options=--jobs:: action=store_var name=job_count description='Number of concurrent jobs'
    long_options=--command:: action=store_var name=command_string description='shell command to run on input datum'
    long_options=--conversion:: action=store_var name=conversion_string description='jq command for input datum'
    long_options=--source:: action=store_var name=source_file description='stream to read from'
"

if ! optionslib::parse::parse_arguments "$@"
then
    exit 255
fi

#===================================================================================
#
#===================================================================================
# See: https://stackoverflow.com/questions/54725080/using-jq-how-can-i-split-a-json-stream-of-objects-into-separate-files-based-on

_streaming_example() {
    case $BASH_VERSION in ''|[1-3].*|4.0*) echo "ERROR: Bash 4.1 needed" >&2; exit 1;; esac

    declare -A output_fds=( )

    while IFS= read -r -d '' type && IFS= read -r -d '' content; do
    if [[ ${output_fds[$type]} ]]; then  # already have a file handle for this output file?
        curr_fd=${output_fds[$type]}       # reuse it, then.
    else
        exec {curr_fd}>"$type.json"        # open a new output file...
        output_fds[$type]=$curr_fd         # and store its file descriptor for use.
    fi
    printf '%s\n' "$content" >&"$curr_fd"
    done < <(jq -j '(.type) + "\u0000" + (. | tojson) + "\u0000"')
}

# See https://stackoverflow.com/questions/8677546/reading-null-delimited-strings-through-a-bash-loop
#     The following code works when reading from a file, but I need to read from a variable containing text.
# _read_to_null_byte() {
# 
#     while read -d $'\0' line ; do
#         # Code here
#     done < /path/to/inputfile
# }

# See: https://unix.stackexchange.com/questions/25372/turn-off-buffering-in-pipe
#      Turning off line buffering
# stdbuf -i0 -o0 -e0 command

# Demo
# while true; do cat jsonstream.txt; sleep 2; done | stdbuf -i0 -o0 -e0 jq -j '(. | tojson) + "\u0000"' | while read -d $'\0' x; do echo "$x"; break; done;
#===================================================================================
#
#===================================================================================
supervisor() {
    local _source _cmd _count

    _source="${1:?Need to provide source file}" || return $?
    _cmd="${2:?Need to provide command string}" || return $?
    _count="${3:?Need to provide number of concurrent tasks}" || return $?

    local -A _tasklist _results
    local _exitcode _sleeper _pid _json _readstatus
    local _waittime=2 _eof=0

    exec 11<&0 12>&1 13>&2 # Capture stdin, stdout & stderr

    stdbuf -i0 -o0 tail --bytes=+0 --follow=name "${_source}" | stdbuf -i0 -o0 jq -j '(. | tojson) + "\u0000"' | {
        while [ "${#_tasklist[@]}" -gt 0 -o "${_eof}" = 0 ]
        do
            # Start new jobs if the tasklist allows it
            if [ "${#_tasklist[@]}" -lt "${_count}" -a "${_eof}" = 0 ]
            then
                read -t ${_waittime} -d $'\0' _json
                _readstatus=$?

                case ${_readstatus} in
                    0)
                        bash -c "${_cmd}" -- "${_json}" <<< "${_json}" >&12 2>&13 & _pid=$!
                        _tasklist[${_pid}]="${_json}"
                        logging::info "Started pid ${_pid} with payload ${_json}"
                        ;;

                    1)
                        logging::info "EOF reached on input stream"
                        _eof=1
                        ;;

                    142)
                        logging::info "Timeout on input stream"
                        ;;

                    *)
                        ;;
                esac
            fi

            sleep ${_waittime} & _sleeper=$!
            wait -n -p _pid ${_sleeper} ${!_tasklist[@]} # Wait for one of the pids to exit
            _exitcode=$?

            if [[ "${_pid}" != "${_sleeper}" ]]
            then
                _json="${_tasklist[${_pid}]}"
                logging::info "Process ${_pid} payload ${_json} exited with ${_exitcode}"
                _results[${_pid}]=${_exitcode}
                unset _tasklist[${_pid}]
                kill "${_sleeper}" >/dev/null 2>&1
                wait "${_sleeper}"
            fi
        done

        logging::info "All tasks have completed"
    }
}

#===================================================================================
#
#===================================================================================
supervisor "${source_file}" "${command_string}" "${job_count}"
